# c++ server Note

### 1.epoll

#### 1.1 概念

```
    epoll是Linux中的一种I/O多路复用技术，它提供了一种高效的方式来监听多个文件描述符的状态变化
```

#### 1.2 触发模式

```
LT（Level Trigger）水平触发
    在LT触发模式下，当文件描述符的状态发生变化时，epoll_wait()函数会返回相应的事件。无论事件是可读还是可写，都会被触发并返回。

ET（Edge Trigger）边缘触发
    在ET触发模式下，只有当文件描述符由不可读/不可写状态变为可读/可写状态时，epoll_wait()函数才会返回相应的事件.

    epoll默认采用LT触发模式，即水平触发，只要fd上有事件，就会一直通知内核。这样可以保证所有事件都得到处理、不容易丢失，但可能
    发生的大量重复通知也会影响epoll的性能。如使用ET模式，即边缘触法，fd从无事件到有事件的变化会通知内核一次，之后就不会再次通知内核。
    这种方式十分高效，可以大大提高支持的并发度
```

### 2.如何深刻理解 Reactor 和 Proactor？

```
    首先无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I/O 事件，
    而 Proactor 模式则是基于「已完成」的 I/O 事件
```

#### 2.1 Reactor

```
    Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，
    就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，
    这个过程是同步的，读取完数据后应用进程才能处理数据。
```

#### 2.2 Proactor

```
    Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，
    这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起
    read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。
```

#### 2.3 总结

```
    因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，
    处理完再通知应用进程」。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核
    以及从内核读取到用户空间。
```
